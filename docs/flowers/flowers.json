[
  {
    "path": "flowers/2021-04-10-mapa-con-elevacin-de-pancrudo/",
    "title": "Mapa con las elevaciones de Pancrudo",
    "description": "El objetivo es hacer uno o varios mapas con datos de elevación del terreno. Seguramente haré uno para Pancrudo y alguno más.",
    "author": [
      {
        "name": "Pedro J. Pérez",
        "url": {}
      }
    ],
    "date": "2021-04-10",
    "categories": [
      "maps"
    ],
    "contents": "\n\nContents\nIntro\nDatos de elevación\nHaciendo el plot\nVariaciones/mejorando el plot\nMunicipios vecinos de Pancrudo\nPueblos del municipio de Pancrudo\n\n\nIntro\nVoy a hacer unos mapas con datos de elevación del terreno. ¿Que por qué? Pues resulta que no se muy bien cómo, llegué a esta web donde explican cómo descargar datos de elevación del terreno usando el paquete de R elevatr. He probado un poco con el paquete y me ha salido a la primera, todo muy fácil, así que, aquí estoy redactando el post. Además, recuerdo que hace tiempo vi un post con datos de elevación de la provincia de Granada en el que se hacía un gráfico parecido a la portada de Unknown Pleasures, el primer disco de Joy Division e intente replicarlo pero no conseguí bajarme datos de elevación, tampoco lo intente massa, pero ahora ya tengo los datos de elevación, así que a ver si me sale o encuentro el post, que no quiero calentarme mucho el cap. Si consigo hacer un plot replicando la portada de Joy Division, añadiré al post la categoría de aRt. Acabo de encontrar el post, es de Daniel Redondo: Mapas estilo Joy Division con QGIS y R. No confío mucho en que me salga, no quiero perder massa temps, pero como me salga hago camisetas per tutti.\nDatos de elevación\nLa página rspatialdata da acceso a distintos tipos de datos espaciales: temperatura, lluvia, … Concretamente, los datos de elevación son accesibles desde R con el paquete elevatr. En está página se explica de donde proceden los datos y cómo hacer uso de ellos. Es muy fácil!!\nPara descargar los datos de elevación hace falta tener la geometría del país/región que te interesa. Yo voy a usar datos del paquete LAU2boundaries4Spain, para algo lo he hecho yo, pero el análisis en el que me baso usa el paquete rgeoboundaries.\nPor ejemplo, para descargar datos de elevación de mi pueblo, Pancrudo, he de:\n\n\nEl código:\n\n#- hace falta tener la geometría, en este caso de Pancrudo\n#- remotes::install_github(\"rOpenSpain/LAU2boundaries4spain\")\nmunicipios <- LAU2boundaries4spain::municipios_2021 \n\npancrudo_bound <- municipios %>% filter(ine_muni.n == \"Pancrudo\")\naa <- sf::st_touches(pancrudo_bound, municipios)[[1]]\npancrudo_vecinos <- municipios %>% slice(aa)\n\n\n#- bajamos datos de elevación (Pancrudo) -----------------\nelevation_data <- elevatr::get_elev_raster(locations = pancrudo_bound, z = 9, clip = \"locations\")\n#- convertimos en data.frame y arreglamos\nelevation_data <- as.data.frame(elevation_data, xy = TRUE)\ncolnames(elevation_data)[3] = \"elevation\"\n#- quitamos NA's\nelevation_data <- elevation_data[complete.cases(elevation_data),] \n\n\n\nHaciendo el plot\nYa tenemos todo lo necesario para hacer el plot, así que:\n\n\nEl código:\n\n#- el plot (sin vecinos) ------------------\np <- ggplot() +\n  #geom_sf(data = pancrudo_vecinos, color = \"grey\", fill = NA) +\n  #geom_label(data = pancrudo_vecinos, color = \"grey\", fill = NA) +\n  geom_raster(data = elevation_data, aes(x = x, y = y, fill = elevation)) +\n  geom_sf(data = pancrudo_bound, color = \"black\", fill = NA) +\n  coord_sf() +\n  #scale_fill_gradient(colours = terrain.colors(10)) +\n  scale_fill_gradient(low = \"white\", high = \"brown\") +\n  #scale_fill_gradient(low = \"grey90\", high = \"black\") +\n  #scale_fill_viridis_c(direction = -1, guide = guide_legend(direction = \"horizontal\")) +\n  ggtitle(\"Relieve de Pancrudo\") + \n  pjpv2020.01::theme_pjp_maps() +\n  ggplot2::theme(legend.position = c(0.1, 0.75)) +\n  ggplot2::theme(legend.background = \n                   ggplot2::element_rect(fill = NA , color = NA)) +\n  labs(caption = \"Datos de elevación del paquete elevatr\\n Geometrías del paquete LAU2boundaries4spain | Visualización: @pjpv4444\") +\n  theme(plot.caption = element_text(size = 7))\np\n\nggsave(p, filename = here::here(\"imagenes\", \"relieve_elevacion_Pancrudo.png\"),\n       device = \"png\", width = 10, height = 13, units = \"cm\")\n\n#- OK, conseguido. A ver si puedo mejorarlo algo!!!\n#- primero simplement cambiar el color y ...\n#- whit tinter pkg: https://github.com/sebdalgarno/tinter\nlibrary(tinter)\nhex <- \"#335CAC\"\ntinter(hex, steps = 10, crop = 7)\n\np_blue <- p +  scale_fill_gradientn(colours = tinter(hex, steps = 10)) +\n  theme(legend.position =\"bottom\")\n\nggsave(p_blue, filename = here::here(\"imagenes\", \"relieve_elevacion_Pancrudo_blue.png\"),\n       device = \"png\", width = 10, height = 13, units = \"cm\")\n\nlibrary(patchwork)\np_mas_blue <- p + p_blue\n\nggsave(p_mas_blue, filename = here::here(\"imagenes\", \"relieve_elevacion_Pancrudo_2.png\"),\n       device = \"png\", width = 20, height = 15, units = \"cm\")\n\n\n\n\n\n\n\nHay algunos fallitos, pero como dice mi hijo, pues ya estaría.\nVariaciones/mejorando el plot\nLa verdad es que ya que me he puesto, voy a hacer varias cosas que me apetecen:\nponer en el mapa a los pueblos vecinos de Pancrudo y ver si están más altos que nosotros,\nsituar en el mapa a los cuatro pueblos del municipio de Pancrudo\nsituar los montes de Pancrudo (El Morteruelo y amigos)\nMunicipios vecinos de Pancrudo\nMunicipios que no pueblos, porque el pueblo más cercano a Pancrudo es Cervera del Rincón, pero los 2 pueblos pertenecen al municipio de Pancrudo. El proceso es muy-muy parecido. Los datos de altitud del relieve proceden del paquete elevatr, mientras que la geolocalización y datos de altitud de los municipios proceden del Nomenclátor Geográfico de Municipios y Entidades de Población.\n\n\nEl código:\n\n#- el plot (con vecinos) --------------\np_vecinos <- ggplot() +\n  #- datos de elevación del terreno\n  geom_raster(data = elevation_data_vecinos, aes(x = x, y = y, fill = elevation)) +\n  #- geometrias de los municipios vecinos\n  geom_sf(data = pancrudo_vecinos, color = \"grey5\", fill = NA) +\n  #- los municipios vecinos\n  geom_point(data = pancrudo_vecinos, aes(x = X, y = Y), color = \"grey5\", fill = NA) +\n  geom_text(data = pancrudo_vecinos, \n            aes(x = X, y = Y-0.009, label = glue::glue(\"{ine_muni.n}\\n({ALTITUD})\")),\n            color = \"grey5\", fontface = \"bold\",  check_overlap = TRUE, size = 2.2) +\n  #- datos de elevacion de Pancrudo\n  geom_raster(data = elevation_data, aes(x = x, y = y, fill = elevation)) +\n  #- geometria de Pancrudo\n  geom_sf(data = pancrudo_bound, color = \"black\", fill = NA, size = 0.8) +\n  #- municipio de Pancrudo\n  geom_point(data = pancrudo_bound, aes(x = X, y = Y), color = \"darkgreen\", fill = NA, shape = 15, size = 2) +\n  geom_text(data = pancrudo_bound, \n            aes(x = X+0.007, y = Y-0.01, label = glue::glue(\"{ine_muni.n}\\n(1233)\")),\n            color = \"darkgreen\", fontface = \"bold\",  check_overlap = TRUE, size = 3.1) +\n  coord_sf() +\n  #- pruebo varias escalas\n  #scale_fill_gradient(colours = terrain.colors(10)) +\n  scale_fill_gradient(low = \"white\", high = \"brown\") +\n  #scale_fill_gradient(low = \"grey90\", high = \"black\") +\n  #scale_fill_viridis_c(direction = -1, guide = guide_legend(direction = \"horizontal\")) +\n  ggtitle(\"Relieve de Pancrudo (y vecinos)\") + \n  pjpv2020.01::theme_pjp_maps() +\n  ggplot2::theme(legend.position = c(0.07, 0.82)) +\n  ggplot2::theme(legend.background = \n                   ggplot2::element_rect(fill = NA , color = NA)) +\n  labs(caption = \"Datos de elevación del paquete elevatr\\n Geometrías del paquete LAU2boundaries4spain | Visualización: @pjpv4444\") +\n  theme(plot.caption = element_text(size = 7))\n\np_vecinos\n\nggsave(p_vecinos, filename = here::here(\"imagenes\", \"relieve_elevacion_Pancrudo_vecinos.png\"),\n       device = \"png\", width = 18, height = 14, units = \"cm\")\n\n\n\n\n\n\nBueno, como veis, casi toda la zona está por encima de 1000 metros. Rillo es el pueblo que más alto está, nos ganan por un poquito!!!\n\nPueblos del municipio de Pancrudo\nEl municipio de Pancrudo tiene 4 pueblos y quiero situar a los cuatro en el mapa. Podría usar datos del IGN de Entidades, pero prefiero geolocalizar. ¿Para que ir andando si se puede ir a rastras?1 Vamos allá.\nPara geolocalizar uso el paquete tidygeocoder:\n\n\nEl código:\n\n#- voy a geolocalizar ----------\npueblos <- tibble::tibble(\n  pueblo = c(\"Cervera del Rincón\" ,   \"Cuevas de Portalrubio\", \"Pancrudo\",\"Portalrubio\"  ),\n  provincia = \"Teruel\",\n  pais = \"Spain\")\npueblos <- pueblos %>% mutate(text_to_geocode = paste(pueblo, provincia, pais, sep = \", \"))\n\n# now geocode -----\nlibrary(tidygeocoder)\npueblos <- pueblos %>% tidygeocoder::geocode(text_to_geocode, method = \"osm\") %>% dplyr::select(- text_to_geocode)\n\n# convert coordinates to an sf object\n#pueblos <- pueblos %>% sf::st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326)\n\n\n\nYa que me pongo, voy a situar también en el mapa los montes y las fuentes de Pancrudo. A ver si ya me aprendo sus nombres y donde están!! Los datos de los montes y fuentes proceden del Nomenclátor Geográfico Básico de España.\nPara hacer el mapa final que muestro, he hecho un mapa para los montes, otro para las fuentes y los he unido con pactwork después he creado el título y la caption con el paquete cowplot.\n\n\nEl código:\n\n#- situo los 4 pueblos como puntos\npp <- p + geom_point(data = pueblos, aes(x = long, y = lat), shape = 15, color = \"darkgreen\", size = 2.5) + \n  #geom_point(data = pueblos1, aes(x = LONGITUD_ETRS89, y = LATITUD_ETRS89), color = \"purple\") + \n  #ggrepel::geom_label_repel(data = pueblos, aes(x = long, y = lat, label = pueblo)) +\n  geom_text(data = pueblos, \n           aes(x = long, y = lat+0.003, label = pueblo),\n           color = \"darkgreen\", fontface = \"bold\",  check_overlap = TRUE, size = 3.1) \npp\n#- meto los accidentes geograficos de Pancrudo (nomenclator geografico del IGN)\naccidentes <- rio::import(\"/home/pjpv/Escritorio/my_datos_2021/datos/IGN/pancrudo_IGN_nomenclator_geografico.rds\")\ntipos_acc <- accidentes %>% distinct(codigo_ngbe, codigo_ngbe_text)\naccidentes_montes <- accidentes %>% filter(codigo_ngbe %in% c(\"4.1.3\", \"4.1.2\"))\naccidentes_fuentes <- accidentes %>% filter(codigo_ngbe %in% c(\"5.5\"))\naccidentes_vertices <- accidentes %>% filter(codigo_ngbe %in% c(\"2.3.1\"))\n\njanitor::tabyl(accidentes, codigo_ngbe_text )\n\npp_montes <- pp + \n  geom_point(data = accidentes_montes, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95), color = \"black\", shape = 17) +\n  geom_point(data = accidentes_vertices, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95), color = \"black\", shape = 8) +\n  geom_text(data = accidentes_vertices, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95+0.003, label = identificador_geografico),\n            color = \"black\", check_overlap = TRUE, size = 3) +\n  geom_text(data = accidentes_montes, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95-0.002, label = identificador_geografico),\n            color = \"black\", check_overlap = TRUE, size = 2.5) +\n  labs(title = \"Montes de Pancrudo\",\n       caption = \"\") +\n  theme(legend.position = \"none\") +\n  theme(plot.title = element_text(color = \"saddlebrown\"))+\n    theme(plot.title = element_text(hjust = 0.5))     # Center ggplot title\n  \npp_fuentes <- pp + \n  geom_point(data = accidentes_fuentes, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95), color = \"navyblue\") +\n  geom_text(data = accidentes_fuentes, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95-0.002, label = identificador_geografico),\n       color = \"navyblue\", check_overlap = TRUE, size = 2.5) +\n  labs(title = \"Fuentes de Pancrudo\", caption = \"\") +\n  theme(plot.title = element_text(color = \"midnightblue\"))+\n  theme(plot.title = element_text(hjust = 0.5))     # Center ggplot title\n\n#- OK voy a juntar pp_fuentes y pp_montes en un gráfico con patch y luego le voy a añadir label y caption con cowplot\nlibrary(patchwork)\nppp <- pp_montes + pp_fuentes\n\nppp\n\nlibrary(cowplot)\ntitle <- ggdraw() +\n  draw_label(\"Relieve del municipio de Pancrudo\",\n             fontfamily = \"DejaVu Serif Condensed\",\n             #colour = \"lightpink4\",\n             hjust = 0.5, size = 24)\n\ncaption <- ggdraw() +\n  draw_label(\"\\n Datos de montes y fuentes del IGN | Datos de elevación del paquete elevatr\\n Geometrías del paquete LAU2boundaries4spain | Visualización: @pjpv4444\",\n             #fontfamily = \"DejaVu Serif Condensed\",\n             #colour = \"lightpink4\",\n             hjust = 0.5,\n             size = 8) \npppp <- plot_grid(title,\n               #plot_grid(ppp, nrow = 1, rel_widths = c(0.5, 0.5)),\n               ppp,\n               caption,\n               ncol = 1,\n               rel_heights = c(0.15, 0.754, 0.06))\n\npppp\n\n#- no consigo quitar el marco blanco ???\nzz <- pppp + pjpv2020.01::theme_pjp_maps()\n  \nzz  + theme(panel.background = ggplot2::element_rect(fill = \"#f5f5f2\", color = \"#f5f5f2\"),\n                   plot.background = ggplot2::element_rect(fill = \"#f5f5f2\", color = NA),\n                   panel.border = ggplot2::element_rect(fill = \"#f5f5f2\", color = NA))\n\nzz\nggsave(zz, filename = here::here(\"imagenes\", \"relieve_elevacion_Pancrudo_fuentes.png\"),\n       device = \"png\", width = 24, height = 17, units = \"cm\")\nknitr::plot_crop(here::here(\"imagenes\", \"relieve_elevacion_Pancrudo_fuentes.png\"))\n\n\n\n\n\n\n\nNo he conseguido quitar el marco blanco pero, ahora sí que ya estaría. El objetivo era hacer un plot a la Joy Division pero me he liado. Lo voy a hacer en el siguiente post que lo voy a hacer rápido-rápido\nPara acabar, el código todo junto:\n\n\nEl código:\n\n#- R script para hacer el flower post de 10 de Abril de 2021\n#- voy a usar datos de elevación de aqui: https://rspatialdata.github.io/elevation.html\n\nlibrary(tidyverse)\nlibrary(raster)\nlibrary(elevatr)\nlibrary(sf)\nlibrary(viridis)\n\n#library(rgeoboundaries) #- remotes::install_gitlab(\"dickoa/rgeoboundaries\")\n#swiss_bound <- geoboundaries(\"Switzerland\")\n#- aa <- rgeoboundaries::gb_adm0(\"Spain\")\n\n#- hace falta tener la geometría, en este caso de Pancrudo\nmunicipios <- pjpv.datos.01::LAU2_muni_2020_canarias\npancrudo_bound <- municipios %>% filter(ine_muni.n == \"Pancrudo\")\naa <- sf::st_touches(pancrudo_bound, municipios)[[1]]\npancrudo_vecinos <- municipios %>% slice(aa)\n\n\n#- bajamos datos de elevación (Pancrudo) -----------------\nelevation_data <- elevatr::get_elev_raster(locations = pancrudo_bound, z = 9, clip = \"locations\")\n#- convertimos en data.frame y arreglamos\nelevation_data <- as.data.frame(elevation_data, xy = TRUE)\ncolnames(elevation_data)[3] = \"elevation\"\n#- quitamos NA's\nelevation_data <- elevation_data[complete.cases(elevation_data),] \n\n\n#- el plot (sin vecinos) ------------------\np <- ggplot() +\n  #geom_sf(data = pancrudo_vecinos, color = \"grey\", fill = NA) +\n  #geom_label(data = pancrudo_vecinos, color = \"grey\", fill = NA) +\n  geom_raster(data = elevation_data, aes(x = x, y = y, fill = elevation)) +\n  geom_sf(data = pancrudo_bound, color = \"black\", fill = NA) +\n  coord_sf() +\n  #scale_fill_gradient(colours = terrain.colors(10)) +\n  scale_fill_gradient(low = \"white\", high = \"brown\") +\n  #scale_fill_gradient(low = \"grey90\", high = \"black\") +\n  #scale_fill_viridis_c(direction = -1, guide = guide_legend(direction = \"horizontal\")) +\n  ggtitle(\"Relieve de Pancrudo\") + \n  pjpv2020.01::theme_pjp_maps() +\n  ggplot2::theme(legend.position = c(0.1, 0.75)) +\n  ggplot2::theme(legend.background = \n                   ggplot2::element_rect(fill = NA , color = NA)) +\n  labs(caption = \"Datos de elevación del paquete elevatr\\n Geometrías del paquete LAU2boundaries4spain | Visualización: @pjpv4444\") +\n  theme(plot.caption = element_text(size = 7))\np\n\nggsave(p, filename = here::here(\"imagenes\", \"relieve_elevacion_Pancrudo.png\"),\n       device = \"png\", width = 10, height = 13, units = \"cm\")\n\n#- OK, conseguido. A ver si puedo mejorarlo algo!!!\n#- primero simplement cambiar el color y ...\n#- whit tinter pkg: https://github.com/sebdalgarno/tinter\nlibrary(tinter)\nhex <- \"#335CAC\"\ntinter(hex, steps = 10, crop = 7)\n\np_blue <- p +  scale_fill_gradientn(colours = tinter(hex, steps = 10)) +\n  theme(legend.position =\"bottom\")\n\nggsave(p_blue, filename = here::here(\"imagenes\", \"relieve_elevacion_Pancrudo_blue.png\"),\n       device = \"png\", width = 10, height = 13, units = \"cm\")\n\n\nlibrary(patchwork)\n\np_mas_blue <- p + p_blue\n\nggsave(p_mas_blue, filename = here::here(\"imagenes\", \"relieve_elevacion_Pancrudo_2.png\"),\n       device = \"png\", width = 20, height = 15, units = \"cm\")\n\n#- Pueblos vecinos --------------------------\n#- bajamos datos de elevación (vecinos Pancrudo) \nelevation_data_vecinos <- elevatr::get_elev_raster(locations = pancrudo_vecinos, z = 9, clip = \"locations\")\n#- convertimos en data.frame y arreglamos\nelevation_data_vecinos <- as.data.frame(elevation_data_vecinos, xy = TRUE)\ncolnames(elevation_data_vecinos)[3] = \"elevation\"\n#- quitamos NA's\nelevation_data_vecinos <- elevation_data_vecinos[complete.cases(elevation_data_vecinos),] \n\n#- altitud de los vecinos (segun IGN)\npueblos_ign <- rio::import(\"/home/pjpv/Escritorio/my_datos_2021/datos/codigos/IGN_municipios.xlsx\") %>% dplyr::select(ine_muni, ine_muni.n, ALTITUD, ine_prov.n)\nnames(pueblos_ign)\npancrudo_vecinos <- left_join(pancrudo_vecinos, pueblos_ign) %>% dplyr::select(ine_muni, ine_muni.n, ALTITUD, ine_prov.n, X, Y)\npancrudo_vecinos <- pancrudo_vecinos %>% mutate(textito = glue::glue(\"{ine_muni.n}\\n({ALTITUD})\"))\n\n\n\n#- el plot (con vecinos) --------------\np_vecinos <- ggplot() +\n  #- datos de elevación del terreno\n  geom_raster(data = elevation_data_vecinos, aes(x = x, y = y, fill = elevation)) +\n  #- geometrias de los municipios vecinos\n  geom_sf(data = pancrudo_vecinos, color = \"grey5\", fill = NA) +\n  #- los municipios vecinos\n  geom_point(data = pancrudo_vecinos, aes(x = X, y = Y), color = \"grey5\", fill = NA) +\n  geom_text(data = pancrudo_vecinos, \n            aes(x = X, y = Y-0.009, label = glue::glue(\"{ine_muni.n}\\n({ALTITUD})\")),\n            color = \"grey5\", fontface = \"bold\",  check_overlap = TRUE, size = 2.2) +\n  #- datos de elevacion de Pancrudo\n  geom_raster(data = elevation_data, aes(x = x, y = y, fill = elevation)) +\n  #- geometria de Pancrudo\n  geom_sf(data = pancrudo_bound, color = \"black\", fill = NA, size = 0.8) +\n  #- municipio de Pancrudo\n  geom_point(data = pancrudo_bound, aes(x = X, y = Y), color = \"darkgreen\", fill = NA, shape = 15, size = 2) +\n  geom_text(data = pancrudo_bound, \n            aes(x = X+0.007, y = Y-0.01, label = glue::glue(\"{ine_muni.n}\\n(1233)\")),\n            color = \"darkgreen\", fontface = \"bold\",  check_overlap = TRUE, size = 3.1) +\n  coord_sf() +\n  #- pruebo varias escalas\n  #scale_fill_gradient(colours = terrain.colors(10)) +\n  scale_fill_gradient(low = \"white\", high = \"brown\") +\n  #scale_fill_gradient(low = \"grey90\", high = \"black\") +\n  #scale_fill_viridis_c(direction = -1, guide = guide_legend(direction = \"horizontal\")) +\n  ggtitle(\"Relieve de Pancrudo (y vecinos)\") + \n  pjpv2020.01::theme_pjp_maps() +\n  ggplot2::theme(legend.position = c(0.07, 0.82)) +\n  ggplot2::theme(legend.background = \n                   ggplot2::element_rect(fill = NA , color = NA)) +\n  labs(caption = \"Datos de elevación del paquete elevatr\\n Geometrías del paquete LAU2boundaries4spain | Visualización: @pjpv4444\") +\n  theme(plot.caption = element_text(size = 7))\n\np_vecinos\n\n\nggsave(p_vecinos, filename = here::here(\"imagenes\", \"relieve_elevacion_Pancrudo_vecinos.png\"),\n       device = \"png\", width = 18, height = 14, units = \"cm\")\n\n#- Poner los 4 pueblos de Pancrudo -----------------\npueblos1 <- rio::import(\"/home/pjpv/Escritorio/my_datos_2021/datos/codigos/IGN_municipios.xlsx\") %>% filter(stringr::str_detect(COD_INE_CAPITAL, \"^44177\"))\n\np + geom_point(data = pueblos1, aes(x = LONGITUD_ETRS89, y = LATITUD_ETRS89))\nnames(pueblos1)\n\n#- voy a geolocalizar ----------\npueblos <- tibble::tibble(\n  pueblo = c(\"Cervera del Rincón\" ,   \"Cuevas de Portalrubio\", \"Pancrudo\",\"Portalrubio\"  ),\n  provincia = \"Teruel\",\n  pais = \"Spain\")\npueblos <- pueblos %>% mutate(text_to_geocode = paste(pueblo, provincia, pais, sep = \", \"))\n\n# now geocode -----\nlibrary(tidygeocoder)\npueblos <- pueblos %>% tidygeocoder::geocode(text_to_geocode, method = \"osm\") %>% dplyr::select(- text_to_geocode)\n\n# convert coordinates to an sf object\n#pueblos <- pueblos %>% sf::st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326)\n\n\n#- situo los 4 pueblos como puntos\npp <- p + geom_point(data = pueblos, aes(x = long, y = lat), shape = 15, color = \"darkgreen\", size = 2.5) + \n  #geom_point(data = pueblos1, aes(x = LONGITUD_ETRS89, y = LATITUD_ETRS89), color = \"purple\") + \n  #ggrepel::geom_label_repel(data = pueblos, aes(x = long, y = lat, label = pueblo)) +\n  geom_text(data = pueblos, \n           aes(x = long, y = lat+0.003, label = pueblo),\n           color = \"darkgreen\", fontface = \"bold\",  check_overlap = TRUE, size = 3.1) \npp\n#- meto los accidentes geograficos de Pancrudo (nomenclator geografico del IGN)\naccidentes <- rio::import(\"/home/pjpv/Escritorio/my_datos_2021/datos/IGN/pancrudo_IGN_nomenclator_geografico.rds\")\ntipos_acc <- accidentes %>% distinct(codigo_ngbe, codigo_ngbe_text)\naccidentes_montes <- accidentes %>% filter(codigo_ngbe %in% c(\"4.1.3\", \"4.1.2\"))\naccidentes_fuentes <- accidentes %>% filter(codigo_ngbe %in% c(\"5.5\"))\naccidentes_vertices <- accidentes %>% filter(codigo_ngbe %in% c(\"2.3.1\"))\n\njanitor::tabyl(accidentes, codigo_ngbe_text )\n\npp_montes <- pp + \n  geom_point(data = accidentes_montes, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95), color = \"black\", shape = 17) +\n  geom_point(data = accidentes_vertices, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95), color = \"black\", shape = 8) +\n  geom_text(data = accidentes_vertices, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95+0.003, label = identificador_geografico),\n            color = \"black\", check_overlap = TRUE, size = 3) +\n  geom_text(data = accidentes_montes, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95-0.002, label = identificador_geografico),\n            color = \"black\", check_overlap = TRUE, size = 2.5) +\n  labs(title = \"Montes de Pancrudo\",\n       caption = \"\") +\n  theme(legend.position = \"none\") +\n  theme(plot.title = element_text(color = \"saddlebrown\"))+\n    theme(plot.title = element_text(hjust = 0.5))     # Center ggplot title\n  \n  \npp_fuentes <- pp + \n  geom_point(data = accidentes_fuentes, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95), color = \"navyblue\") +\n  geom_text(data = accidentes_fuentes, aes(x = long_etrs89_regcan95, y = lat_etrs89_regcan95-0.002, label = identificador_geografico),\n       color = \"navyblue\", check_overlap = TRUE, size = 2.5) +\n  labs(title = \"Fuentes de Pancrudo\", caption = \"\") +\n  theme(plot.title = element_text(color = \"midnightblue\"))+\n  theme(plot.title = element_text(hjust = 0.5))     # Center ggplot title\n\n\n#- OK voy a juntar pp_fuentes y pp_montes en un gráfico con patch y luego le voy a añadir label y caption con cowplot\nlibrary(patchwork)\nppp <- pp_montes + pp_fuentes \n\nlibrary(cowplot)\ntitle <- ggdraw() +\n  draw_label(\"Relieve del municipio de Pancrudo\",\n             fontfamily = \"DejaVu Serif Condensed\",\n             #colour = \"lightpink4\",\n             hjust = 0.5, size = 22)\n\ncaption <- ggdraw() +\n  draw_label(\"\\n Datos de montes y fuentes del IGN | Datos de elevación del paquete elevatr\\n Geometrías del paquete LAU2boundaries4spain | Visualización: @pjpv4444\",\n             #fontfamily = \"DejaVu Serif Condensed\",\n             #colour = \"lightpink4\",\n             hjust = 0.5,\n             size = 8) \n\n\n#-juntos el plot, el label y la caption\npppp <- plot_grid(title,\n               #plot_grid(ppp, nrow = 1, rel_widths = c(0.5, 0.5)),\n               ppp,\n               caption,\n               ncol = 1,\n               rel_heights = c(0.15, 0.754, 0.06))\n\n\npppp\n\n\n#- no consigo quitar el trozo blanco\nzz <- pppp + pjpv2020.01::theme_pjp_maps()\n\nzz  + theme(panel.background = ggplot2::element_rect(fill = \"#f5f5f2\", color = \"#f5f5f2\"),\n            plot.background = ggplot2::element_rect(fill = \"#f5f5f2\", color = NA),\n            panel.border = ggplot2::element_rect(fill = \"#f5f5f2\", color = NA))\n\nzz\n\nggsave(zz, filename = here::here(\"imagenes\", \"relieve_elevacion_Pancrudo_fuentes.png\"),\n       device = \"png\", width = 24, height = 17, units = \"cm\")\n#knitr::plot_crop(here::here(\"imagenes\", \"relieve_elevacion_Pancrudo_fuentes.png\"))\n\n\n\nFIN\n\nAl final en lugar de a rastras he ido para atrás: lo he hecho de las 2 maneras.↩︎\n",
    "preview": "flowers/2021-04-10-mapa-con-elevacin-de-pancrudo/imagenes/relieve_elevacion_Pancrudo_2.png",
    "last_modified": "2021-04-11T21:39:03+02:00",
    "input_file": {},
    "preview_width": 2362,
    "preview_height": 1771
  },
  {
    "path": "flowers/2021-03-02-art-map-de-valencia/",
    "title": "Streetmap de Valencia",
    "description": "En el primer post del renacido blog R & flowers hago, siguiendo el código de este post (https://ggplot2tutor.com/viz-pages/streetmaps/streetmaps) de Christian Burkhart, una visualización de las calles de Valencia: un streetmap.",
    "author": [
      {
        "name": "Pedro J. Pérez",
        "url": {}
      }
    ],
    "date": "2021-03-02",
    "categories": [
      "aRt",
      "street map"
    ],
    "contents": "\n\nContents\nIntro/motivación\naRt map de Valencia\n\nEn el primer post del renacido blog R & flowers hago, siguiendo el código de este post de Christian Burkhart, una visualización de las calles de Valencia: un streetmap.\nIntro/motivación\nResulta que el blog de al lado me está saliendo como muy serio, solo hago que procesar datos del INE y hacer algunas visualizaciones, pero muchas veces juego con R a replicar y modificar análisis que veo on the web, así que he decidido que algunos de estos “análisis” que hago los publicaré aquí. Si no los publico, muchas veces se acaban perdiendo, así que, vamos a ver si soy más organizado y guardo al menos algunos de ellos.\naRt map de Valencia\nEmpiezo R & flowers blog replicando este post de Christian Burkhart. Resulta que Christian tiene unos fantásticos tutoriales, generalmente sobre visualización aquí y topé de casualidad con unos gráficos/visualizaciones chulísimos que había hecho con las calles de su ciudad. Además Christian hacía disponible el código, gracias!!!, así que aquí estoy replicando su análisis para hacer un streetmap de Valencia.\nSu código ha funcionado sin problemas, solo he tenido que cambiar el nombre de la ciudad y sí que al final he añadido algunas lineas para tunear mi visualización, pero cosas menores\n\n\nEl código:\n\n#- Mapa con el callejero de una ciudad: https://ggplot2tutor.com/streetmaps/streetmaps/\n#- https://ggplot2tutor.com/viz-pages/streetmaps/streetmaps/\nlibrary(tidyverse)\nlibrary(osmdata)\nlibrary(sf)\n\naa <- osmdata::available_features()        #- a list of all features\nosmdata::available_tags(\"highway\")   #- all tags of a feature via osmdata\n\nosmdata::getbb(\"Valencia, Spain\")  #- bbox ; he x-value indicates the longitude\n\nmy_city <- \"Valencia, Spain\"\nstreets <- getbb(my_city)%>% opq() %>%\n            add_osm_feature(key = \"highway\", \n                value = c(\"motorway\", \"primary\", \"secondary\", \"tertiary\")) %>% osmdata_sf()\n\n#- small streets\nsmall_streets <- getbb(my_city) %>% opq() %>% \n                 add_osm_feature(key = \"highway\", \n                  value = c(\"residential\", \"living_street\", \n                            \"unclassified\", \"service\", \"footway\")) %>% osmdata_sf()\nzz_4 <- small_streets[[4]]  \nzz_5 <- small_streets[[5]]  \nplot(zz_5, max.plot = 1)\nzz_6 <- small_streets[[6]]  \n\nriver <- getbb(my_city) %>% opq() %>%\n                add_osm_feature(key = \"waterway\", value = \"river\") %>%\n                osmdata_sf()\n\nzz_4 <- river[[4]]  #\nzz_5 <- river[[5]]  \nplot(zz_5, max.plot = 1)\nzz_6 <- river[[6]]  #\n\n#- plot inicial\nggplot() + geom_sf(data = streets$osm_lines, inherit.aes = FALSE, color = \"black\", size = .4, alpha = .8) +\n           geom_sf(data = small_streets$osm_lines, inherit.aes = FALSE, color = \"red\", size = .3, alpha = .07) +                geom_sf(data = river$osm_lines,  inherit.aes = FALSE, color = \"blue\", size = .5, alpha = .5) + \n            coord_sf(xlim = c(-0.45, -0.27), ylim = c(39.27, 39.56), expand = FALSE) \n\n\n#- ya con un poco de color\nggplot() +\n  geom_sf(data = streets$osm_lines,\n          inherit.aes = FALSE,\n          color = \"steelblue\",          size = .4,\n          alpha = .8) +\n  geom_sf(data = small_streets$osm_lines,\n          inherit.aes = FALSE,\n          color = \"black\",\n          size = .4,\n          alpha = .6) +\n  geom_sf(data = river$osm_lines,\n          inherit.aes = FALSE,\n          color = \"black\",\n          size = .2,\n          alpha = .5) +\n  coord_sf(xlim = c(-0.45, -0.27), ylim = c(39.27, 39.56), expand = FALSE) \n\n\n#- gráfico final ---------------------\nlibrary(ggfx)\nlibrary(ragg)\n#- para guardar el plot me apoyé en:\n#- https://github.com/gkaramanis/tidytuesday/tree/master/2021/2021-week8\nagg_png(\"./aRt_map_valencia.png\", res = 300, height = 8, width = 6, units = \"in\")\np <- ggplot() +\n  geom_sf(data = streets$osm_lines,\n          inherit.aes = FALSE, color = \"#7fc0ff\", \n          size = .4, alpha = .8) +\n  geom_sf(data = small_streets$osm_lines,\n          inherit.aes = FALSE, color = \"#ffbe7f\", \n          size = .2, alpha = .6) +\n  geom_sf(data = river$osm_lines,\n          inherit.aes = FALSE, color = \"#ffbe7f\", \n          size = .2, alpha = .5) +\n  coord_sf(xlim = c(-0.44, -0.295), ylim = c(39.415, 39.52), expand = FALSE) +\n  labs(title = \"Valencia, Spain\") +\n  theme_void() +\n  theme(plot.background = element_rect(fill = \"#282828\")  ) +\n  theme(plot.title = element_text(face = \"bold\", \n        color = \"#ffbe7f\", hjust = 0.45, vjust = -161)) + \n  theme(plot.margin = unit(c(0.1, 0.05, 1.7, 0.1), \"cm\")) +\n  theme(plot.background = element_rect(colour = \"snow2\", size = 10.7)) +\n  geom_text(data = data.frame(x = -0.31, y = 39.475, \n        label = \"mar \\n  Mediterráneo\"),\n        mapping = aes(x = x, y = y, label = label),\n        size = 2.82, angle = 77L, hjust = 0, vjust = 0.5, \n        colour = \"#7fc0ff\", inherit.aes = FALSE)\n\nprint(p)\ndev.off()\nknitr::plot_crop(here::here(\"imagenes\", \"aRt_map_valencia.png\"))\n\n\n\nEl resultado:\n\n\n\nFin\nPD: Hoy, jueves 25 de marzo de 2021, he visto este post de Esteban Moro. Me lo apunto por si algún día retomo el mapstreet. Otro más, esta vez de Dean Marchiori y su mapa de Culburra.\n\n\n\n",
    "preview": "flowers/2021-03-02-art-map-de-valencia/imagenes/preview_aRt_map_valencia.png",
    "last_modified": "2021-04-10T10:32:28+02:00",
    "input_file": {},
    "preview_width": 616,
    "preview_height": 322
  }
]
